"use strict";
// Generated by CoffeeScript 1.8.0
(function() {
  var CoreScroller, activatedElement, checkVisibility, doesScroll, findScrollableElement //
    , rsortBy0, firstScrollableElement //
    , getDimension, getSign, performScroll, scrollProperties, shouldScroll;

  activatedElement = null;

  getSign = function(val) {
    return val === 0 ? 0 : val < 0 ? -1 : 1;
  };

  scrollProperties = {
    x: {
      axisName: 'scrollLeft',
      max: 'scrollWidth',
      viewSize: 'clientWidth'
    },
    y: {
      axisName: 'scrollTop',
      max: 'scrollHeight',
      viewSize: 'clientHeight'
    }
  };

  getDimension = function(el, direction, amount) {
    var name;
    if (Utils.isString(amount)) {
      name = amount;
      if (name === 'viewSize' && el === document.body) {
        if (direction === 'x') {
          return window.innerWidth;
        } else {
          return window.innerHeight;
        }
      } else {
        return el[scrollProperties[direction][name]];
      }
    } else {
      return amount;
    }
  };

  performScroll = function(element, direction, amount) {
    var axisName, before;
    axisName = scrollProperties[direction].axisName;
    before = element[axisName];
    element[axisName] += amount;
    return element[axisName] !== before;
  };

  shouldScroll = function(element, direction) {
    var computedStyle, _ref;
    computedStyle = window.getComputedStyle(element);
    if (computedStyle.getPropertyValue("overflow-" + direction) === "hidden") {
      return false;
    }
    if ((_ref = computedStyle.getPropertyValue("visibility")) === "hidden" || _ref === "collapse") {
      return false;
    }
    if (computedStyle.getPropertyValue("display") === "none") {
      return false;
    }
    return true;
  };

  doesScroll = function(element, direction, amount, factor) {
    var delta = factor * getDimension(element, direction, amount);
    delta = delta ? getSign(delta) : -1;
    return performScroll(element, direction, delta) && performScroll(element, direction, -delta);
  };

  findScrollableElement = function(element, direction, amount, factor) {
    while (element !== document.body && !(doesScroll(element, direction, amount, factor) && shouldScroll(element, direction))) {
      element = element.parentElement || document.body;
    }
    return element;
  };
  
  rsortBy0 = function(a, b) {
    return b[0] - a[0];
  };

  firstScrollableElement = function(element) {
    var child, children, rect, _i, _len, _ref;
    if (element == null) {
      element = document.body;
    }
    if (doesScroll(element, "y", 1, 1) || doesScroll(element, "y", -1, 1)) {
      return element;
    }
    children = [];
    for (_ref = element.children, _i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (rect = DomUtils.getVisibleClientRect(child)) {
        children.push([rect.width * rect.height, child]);
      }
    }
    children = children.sort(rsortBy0);
    for (_i = 0, _len = children.length; _i < _len; _i++) {
      if (child = firstScrollableElement(children[_i][1])) {
        return child;
      }
    }
    return null;
  };

  checkVisibility = function(element) {
    var rect;
    rect = activatedElement.getBoundingClientRect();
    if (rect.bottom < 0 || rect.top > window.innerHeight || rect.right < 0 || rect.left > window.innerWidth) {
      return activatedElement = element;
    }
  };

  CoreScroller = {
    smoothScroll: true,
    time: 0,
    isLastEventRepeat: false,
    keyIsDown: false,
    init: function() {
      handlerStack.push({
        keydown: function(event) {
          CoreScroller.keyIsDown = true;
          CoreScroller.isLastEventRepeat = event.repeat;
          return true;
        },
        keyup: function() {
          CoreScroller.keyIsDown = false;
          CoreScroller.time += 1;
          return true;
        }
      });
    },
    wouldNotInitiateScroll: function() {
      return this.smoothScroll && (this.isLastEventRepeat);
    },
    minCalibration: 0.5,
    maxCalibration: 1.6,
    calibrationBoundary: 150,
    scroll: function(element, direction, amount) {
      var activationTime, animate, calibration, duration, myKeyIsStillDown, previousTimestamp, sign, totalDelta, totalElapsed, _ref;
      if (!amount) {
        return;
      }
      if (!this.smoothScroll) {
        performScroll(element, direction, amount);
        checkVisibility(element);
        return;
      }
      if (this.isLastEventRepeat) {
        return;
      }
      activationTime = ++this.time;
      myKeyIsStillDown = (function(_this) {
        return function() {
          return _this.time === activationTime && _this.keyIsDown;
        };
      })(this);
      sign = getSign(amount);
      amount = Math.abs(amount);
      duration = Math.max(100, 20 * Math.log(amount));
      totalDelta = 0;
      totalElapsed = 0.0;
      calibration = 1.0;
      previousTimestamp = null;
      animate = (function(_this) {
        return function(timestamp) {
          var delta, elapsed;
          if (previousTimestamp == null) {
            previousTimestamp = timestamp;
          }
          if (timestamp === previousTimestamp) {
            return requestAnimationFrame(animate);
          }
          elapsed = timestamp - previousTimestamp;
          totalElapsed += elapsed;
          previousTimestamp = timestamp;
          if (myKeyIsStillDown() && 75 <= totalElapsed && (_this.minCalibration <= calibration && calibration <= _this.maxCalibration)) {
            if (1.05 * calibration * amount < _this.calibrationBoundary) {
              calibration *= 1.05;
            }
            if (_this.calibrationBoundary < 0.95 * calibration * amount) {
              calibration *= 0.95;
            }
          }
          delta = Math.ceil(amount * (elapsed / duration) * calibration);
          delta = myKeyIsStillDown() ? delta : Math.max(0, Math.min(delta, amount - totalDelta));
          if (delta && performScroll(element, direction, sign * delta)) {
            totalDelta += delta;
            return requestAnimationFrame(animate);
          } else {
            return checkVisibility(element);
          }
        };
      })(this);
      requestAnimationFrame(animate);
    }
  };

  (typeof exports !== "undefined" && exports !== null ? exports : window).Scroller = {
    init: function() {
      handlerStack.push({
        DOMActivate: function() {
          activatedElement = event.target;
          return true;
        }
      });
      CoreScroller.init();
    },
    setSmoothScroll: function(smoothScroll) {
      CoreScroller.smoothScroll = smoothScroll;
    },
    scrollBy: function(direction, amount, factor) {
      var element, elementAmount;
      if (factor == null) {
        factor = 1;
      }
      if (!document.body && amount instanceof Number) {
        if (direction === "x") {
          window.scrollBy(amount, 0);
        } else {
          window.scrollBy(0, amount);
        }
        return;
      }
      activatedElement || (activatedElement = document.body && firstScrollableElement());
      if (!activatedElement) {
        return;
      }
      if (!CoreScroller.wouldNotInitiateScroll()) {
        element = findScrollableElement(activatedElement, direction, amount, factor);
        elementAmount = factor * getDimension(element, direction, amount);
        CoreScroller.scroll(element, direction, elementAmount);
      }
    },
    scrollTo: function(direction, pos) {
      var amount, element;
      activatedElement || (activatedElement = document.body && firstScrollableElement());
      if (!activatedElement) {
        return;
      }
      element = findScrollableElement(activatedElement, direction, pos, 1);
      amount = getDimension(element, direction, pos) - element[scrollProperties[direction].axisName];
      CoreScroller.scroll(element, direction, amount);
    }
  };

})();
