// Generated by CoffeeScript 1.8.0
(function() {
  "use strict";
  var HUD, Tween, currentCompletionKeys //
    , enterInsertModeWithoutShowingIndicator, executeFind, exitFindMode //
    , exitInsertMode, findAndFocus, findMode, findChangeListened //
    , findModeAnchorNode, findModeQuery, findModeQueryHasResults, focusFoundLink, followLink //
    , frameId, getNextQueryFromRegexMatches, handleDeleteForFindMode //
    , handleEnterForFindMode, handleEscapeForFindMode, handleKeyCharForFindMode, KeydownEvents //
    , hideHelpDialog, CursorHider, ELs //
    , initializeWhenEnabled, insertModeLock, isDOMDescendant //
    , isEditable, isEmbed, isEnabledForUrl, isFocusable, isInsertMode, isPassKey, isShowingHelpDialog //
    , isValidKey, keyQueue //
    , passKeys, performFindInPlace //
    , restoreDefaultSelectionHighlight //
    , settings, showFindModeHUDForQuery, textInputXPath, oldActivated //
    , updateFindModeQuery, validFirstKeys, goBy, getVisibleInputs, mainPort, requestHandlers //
    ;
  
  frameId = Math.floor(Math.random() * 999999997) + 2;

  if (window._DEBUG) {
    var time1 = Date.now(); console.log("v++", time1, "@f", frameId);
  }

  insertModeLock = null;

  findMode = false;
  
  findChangeListened = 0;

  findModeQuery = {
    rawQuery: "",
    matchCount: 0,
    parsedQuery: "",
    isRegex: false,
    ignoreCase: false,
    activeRegexIndex: 0,
    regexMatches: null
  };

  findModeQueryHasResults = false;

  findModeAnchorNode = null;

  isShowingHelpDialog = false;

  isEnabledForUrl = true;

  passKeys = "";

  keyQueue = "";

  currentCompletionKeys = [];

  validFirstKeys = [];
  
  oldActivated = {
    target: null,
    isSecond: false
  }

  textInputXPath = DomUtils.makeXPath([
    'input[not(@disabled or @readonly) and (@type="text" or @type="search" or @type="email" \
or @type="url" or @type="number" or @type="password" or @type="date" or @type="tel" or not(@type))]',
    "textarea",
    "*[@contenteditable='' or translate(@contenteditable, 'TRUE', 'true')='true']"
  ]);
  
  mainPort = {
    fakePort: {
      postMessage: function() {}
    },
    responseTimeout: 2000,
    autoReconnectTimeout: 1000,
    _name: "main",
    _port: null,
    _listener: null,
    _callbacks: {},
    _hasCallbacks: false,
    _lastWaitTime: 0,
    _connectFailCount: 0,
    postMessage: function(request, callback) {
      if (callback) {
        request = {
          _msgId: Utils.createUniqueId(),
          request: request
        };
      }
      try {
        this._get().postMessage(request);
      } catch (e) {
        this._port = this.fakePort;
        setTimeout(this._ClearPort, this.autoReconnectTimeout);
        if (window._DEBUG)
          console.log("vim pM fail:", request);
      }
      var _ref, _i = Date.now();
      if (this._hasCallbacks && _i > this._lastWaitTime + this.responseTimeout) {
        _ref = this._callbacks;
        this._hasCallbacks = false;
        this._callbacks = {};
      }
      if (callback) {
        this._lastWaitTime = _i;
        if (this._port !== this.fakePort) {
          this._callbacks[request._msgId] = callback;
          this._hasCallbacks = true;
        } else {
          setTimeout(callback.bind(null, undefined, -request._msgId), 34);
        }
      }
      if (_ref) {
        setTimeout(function() {
          var _i, fn;
          for (_i in _ref) {
            fn = _ref[_i];
            fn(undefined, -_i);
          }
        }, 17);
      }
      return (this._port === this.fakePort) ? (callback ? -request._msgId : -1)
        : callback ? request._msgId : 1;
    },
    getListener: function() {
      return this._listener;
    },
    setListener: function(listener) {
      if (this._port && this._port.onMessage) {
        if (this._listener) {
          this._port.onMessage.removeListener(this._listener);
        }
        this._port.onMessage.addListener(listener);
      }
      this._listener = listener;
    },
    setPortName: function(name) {
      this._name = name;
      if (this._port && this._port.name != null) {
        this._port.name = name;
      }
    },
    DefaultListener: function(response) {
      var id, name, handler;
      if (id = response._msgId) {
        if (handler = mainPort._callbacks[id]) {
          delete mainPort._callbacks[id];
          handler(response.response, id);
        }
        return;
      }
      name = response.name;
      if (isEnabledForUrl || (name === "getActiveState" || name === "setState")) {
        if (handler = requestHandlers[name]) {
          handler(response);
        }
      }
    },
    _ClearPort: function() {
      mainPort._port = null;
    },
    _get: function() {
      var port = this._port;
      if (port) {
        return port;
      }
      try {
        port = this._port = chrome.runtime.connect({ name: this._name });
      } catch (e) { // the extension is reloaded
        if (!(this._connectFailCount > 0)) {
          this._connectFailCount = Date.now();
        } else if (Date.now() - this._connectFailCount > 3000) {
          isEnabledForUrl = false;
          ELs.destroy();
          return this.fakePort;
        }
        throw e;
      }
      this._connectFailTime = 0;
      port.onDisconnect.addListener(this._ClearPort);
      if (this._listener) {
        port.onMessage.addListener(this._listener);
      }
      return port;
    }
  };
  mainPort._listener = mainPort.DefaultListener;

  settings = {
    values: {},
    valuesToLoad: ["scrollStepSize", "linkHintCharacters", "linkHintNumbers", "filterLinkHints" //
      , "hideHud", "previousPatterns", "nextPatterns", "findModeRawQuery", "regexFindMode" //
      , "helpDialog_showAdvancedCommands", "smoothScroll", "showOmniRelevancy" //
      , "findModeRawQueryList"
    ], // should be the same as bg.Settings.valuesToLoad
    isLoading: 0,
    request2: null,
    _eventListeners: {},
    autoRetryInterval: 2000,
    set: function(key, value) {
      this.values[key] = value;
      mainPort.postMessage({
        handlerSettings: "set",
        key: key,
        value: value
      });
    },
    load: function(values, force, request2) {
      if (!this.isLoading) {
        this.isLoading = setInterval(this.load.bind(this, values, true, null), this.autoRetryInterval);
      } else if (force !== true) {
        return 0;
      }
      if (values) {
        (values.length > 0) ? (this.valuesToLoad = values) : (values = null);
      }
      this.request2 = request2 || this.request2;
      return mainPort.postMessage({
        handlerSettings: "get",
        keys: values,
        request: this.request2
      });
    },
    ReceiveMessage: function(response) {
      var _this = settings, ref = response.keys || _this.valuesToLoad, i, v1, v2, func;
      for (v1 = response.values, v2 = _this.values, i = v1.length; 0 <= --i; ) {
        v2[ref[i]] = v1[i];
      }
      if (i = _this.isLoading) {
        clearInterval(i);
        _this.isLoading = 0;
      }
      _this.request2 = null;
      func = response.keys ? "get" : "load";
      ref = _this._eventListeners;
      v1 = ref[func];
      delete ref[func];
      response = response.response;
      for (i = 0; i < v1.length; i++) {
        if (func = v1[i]) {
          func(response);
        }
      }
    },
    addEventListener: function(eventName, callback) {
      if (eventName in this._eventListeners) {
        this._eventListeners[eventName].push(callback);
      } else {
        this._eventListeners[eventName] = [callback];
      }
    }
  };

  ELs = { onUnload: null, onFocus: null, focusMsg: null, //
    onKeydown: null, onKeypress: null, onKeyup: null, //
    docOnFocus: null, onBlur: null, onActivate: null, //
    destroy: null //
  };

  initializeWhenEnabled = function(newPassKeys) {
    initializeWhenEnabled = function(newPassKeys) { passKeys = newPassKeys; };
    passKeys = newPassKeys;
    window.addEventListener("keydown", ELs.onKeydown, true);
    window.addEventListener("keypress", ELs.onKeypress, true);
    window.addEventListener("keyup", ELs.onKeyup = function(event) {
      if (isEnabledForUrl) {
        var handledKeydown = KeydownEvents.pop(event);
        if (handlerStack.bubbleEvent("keyup", event) && handledKeydown) {
          DomUtils.suppressPropagation(event);
        }
      }
    }, true);
    // it seems document.onfocus works (only now).
    document.addEventListener("focus", ELs.docOnFocus = function(event) {
      if (isEnabledForUrl && isFocusable(event.target) && !findMode) {
        enterInsertModeWithoutShowingIndicator(event.target);
        if (!oldActivated.target || oldActivated.isSecond) {
          oldActivated.target = event.target;
          oldActivated.isSecond = true;
        }
      }
    }, true);
    document.addEventListener("blur", ELs.onBlur = function(event) {
      if (isEnabledForUrl && isFocusable(event.target)) {
        exitInsertMode(event.target);
      }
    }, true);
    document.addEventListener("DOMActivate", ELs.onActivate = function(event) {
      if (isEnabledForUrl) {
        handlerStack.bubbleEvent('DOMActivate', event);
      }
    }, true);
    if (window._DEBUG) {
      var time2 = Date.now(); console.log("v++", time2, "=+", time2 - time1);
    }
    if (document.activeElement && isEditable(document.activeElement) && !findMode) {
      enterInsertModeWithoutShowingIndicator(document.activeElement);
    }
  };

  extend(window, {
    scrollToBottom: function() {
      Scroller.scrollTo("y", "max");
    },
    scrollToTop: function() {
      Scroller.scrollTo("y", 0);
    },
    scrollToLeft: function() {
      Scroller.scrollTo("x", 0);
    },
    scrollToRight: function() {
      Scroller.scrollTo("x", "max");
    },
    scrollUp: function() {
      Scroller.scrollBy("y", -1 * (settings.values.scrollStepSize || 100));
    },
    scrollDown: function() {
      Scroller.scrollBy("y", settings.values.scrollStepSize || 100);
    },
    scrollPageUp: function() {
      Scroller.scrollBy("y", "viewSize", -1 / 2);
    },
    scrollPageDown: function() {
      Scroller.scrollBy("y", "viewSize", 1 / 2);
    },
    scrollFullPageUp: function() {
      Scroller.scrollBy("y", "viewSize", -1);
    },
    scrollFullPageDown: function() {
      Scroller.scrollBy("y", "viewSize");
    },
    scrollLeft: function() {
      Scroller.scrollBy("x", -1 * (settings.values.scrollStepSize || 60));
    },
    scrollRight: function() {
      Scroller.scrollBy("x", settings.values.scrollStepSize || 60);
    },

    reload: function() {
      window.location.reload();
    },
    switchFocus: function() {
      var newEl = document.activeElement;
      if (newEl !== document.body) {
        oldActivated.target = newEl;
        oldActivated.isSecond = false;
        if (newEl.blur) {
          newEl.blur();
        }
        return;
      }
      newEl = oldActivated.target;
      if (!newEl || !DomUtils.isVisibile(newEl)) {
        return;
      }
      document.activeElement = newEl;
      oldActivated.target = null;
      if (newEl.scrollIntoViewIfNeeded) {
        newEl.scrollIntoViewIfNeeded();
      } else if (newEl.scrollIntoView) {
        newEl.scrollIntoView();
      }
      DomUtils.simulateHover(newEl);
      if (newEl.focus) {
        newEl.focus();
      }
    },
    simBackspace: function() {
      var el = document.activeElement;
      if (el === document.body) {
        switchFocus();
      } else if (!DomUtils.isVisibile(el) || !isEditable(el)) {
        return;
      }
      DomUtils.simulateBackspace(el);
    },
    goBack: function(count) {
      history.go(-count);
    },
    goForward: function(count) {
      history.go(count);
    },
    goUp: function(count) {
      var url, urlsplit;
      url = window.location.href;
      if (url[url.length - 1] === "/") {
        url = url.substring(0, url.length - 1);
      }
      urlsplit = url.split("/");
      if (urlsplit.length > 3) {
        urlsplit = urlsplit.slice(0, Math.max(3, urlsplit.length - count));
        window.location.href = urlsplit.join('/');
      }
    },
    goToRoot: function() {
      window.location.href = window.location.origin;
    },
    showHelp: function(request) {
      mainPort.postMessage({
        handler: "initHelp",
      }, showHelpDialog);
    },
    toggleViewSource: function() {
      mainPort.postMessage({
        handler: "getCurrentTabUrl"
      }, function(url) {
        if (url.substring(0, 12) === "view-source:") {
          url = url.substring(12);
        } else {
          url = "view-source:" + url;
        }
        mainPort.postMessage({
          handler: "openUrlInNewTab",
          url: url
        });
      });
    },
    copyCurrentUrl: function() {
      mainPort.postMessage({
        handler: "getCurrentTabUrl"
      }, function(url) {
        mainPort.postMessage({
          handler: "copyToClipboard",
          data: url
        });
        HUD.showForDuration("Yanked URL" + ((url.length > 28)
            ? (url.substring(0, 25) + "...") : url), 2000);
      });
    },
    focusInput: function(count) {
      var hintContainingDiv, hints, selectedInputIndex, visibleInputs;
      visibleInputs = getVisibleInputs(DomUtils.evaluateXPath(textInputXPath, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE));
      if (visibleInputs.length === 0) {
        return;
      }
      selectedInputIndex = Math.min(count - 1, visibleInputs.length - 1);
      visibleInputs[selectedInputIndex].element.focus();
      if (visibleInputs.length === 1) {
        return;
      }
      hints = visibleInputs.map(function(tuple) {
        var hint = document.createElement("div");
        hint.className = "vimB vimI vimIH";
        hint.style.left = (tuple.rect[0] - 1) + "px";
        hint.style.top = (tuple.rect[1] - 1) + "px";
        hint.style.width = (tuple.rect[2] - tuple.rect[0]) + "px";
        hint.style.height = (tuple.rect[3] - tuple.rect[1]) + "px";
        return hint;
      });
      hints[selectedInputIndex].classList.add('vimS');
      hintContainingDiv = DomUtils.addElementList(hints, {
        id: "vimIMC",
        className: "vimB vimR"
      });
      hintContainingDiv.style.left = window.scrollX + "px";
      hintContainingDiv.style.top = window.scrollY + "px";
      handlerStack.push({
        keydown: function(event) {
          if (event.keyCode === keyCodes.tab) {
            hints[selectedInputIndex].classList.remove('vimS');
            if (event.shiftKey) {
              if (--selectedInputIndex === -1) {
                selectedInputIndex = hints.length - 1;
              }
            } else if (++selectedInputIndex === hints.length) {
              selectedInputIndex = 0;
            }
            hints[selectedInputIndex].classList.add('vimS');
            visibleInputs[selectedInputIndex].element.focus();
          } else if (event.keyCode !== keyCodes.shiftKey) {
            DomUtils.removeNode(hintContainingDiv);
            handlerStack.remove();
            return true;
          }
          return false;
        }
      });
    }
  });

  isPassKey = function(keyChar) {
    return !keyQueue && passKeys.length > 0 && passKeys.indexOf(keyChar) >= 0;
  };

  KeydownEvents = {
    _handledEvents: {},
    stringify: function(event) {
      return [event.metaKey + event.altKey * 2 + event.ctrlKey * 4, event.keyIdentifier
        , event.keyCode].join(",");
    },
    push: function(event) {
      this._handledEvents[this.stringify(event)] = true;
    },
    pop: function(event) {
      var key = this.stringify(event), value = this._handledEvents[key];
      delete this._handledEvents[key];
      return value;
    }
  };

  ELs.onKeypress = function(event) {
    if (!isEnabledForUrl || !handlerStack.bubbleEvent('keypress', event) || event.keyCode <= 31) {
      return;
    }
    var keyChar = String.fromCharCode(event.charCode);
    if (!keyChar) {
      return;
    }
    if (keyChar === "f" && event[keyCodes.modifier]) {
      enterInsertModeWithoutShowingIndicator();
      return;
    }
    if (findMode) {
      handleKeyCharForFindMode(keyChar);
      DomUtils.suppressEvent(event);
      return;
    }
    if (isInsertMode() || isPassKey(keyChar)) {
      return;
    }
    if (isValidKey(keyChar)) {
      DomUtils.suppressEvent(event);
    }
    mainPort.postMessage({
      handlerKey: keyChar
    });
  };

  ELs.onKeydown = function(event) {
    if (!isEnabledForUrl) {
      return;
    } else if (!handlerStack.bubbleEvent('keydown', event)) {
      KeydownEvents.push(event);
      return;
    }
    var modifiers = null, keyChar = "", isInsert = isInsertMode(), isEscape = KeyboardUtils.isEscape(event), action = -1;
    if (((event.metaKey || event.ctrlKey || event.altKey) && event.keyCode > 31) || ! event.keyIdentifier.startsWith("U+")) {
      modifiers = "";
      keyChar = KeyboardUtils.getKeyChar(event);
      if (keyChar.length > 0) {
        if (event.ctrlKey) {
          modifiers += event.metaKey ? "m-c-" : keyCodes.hasMeta ? "C-" : "c-";
        } else if (event.metaKey) {
          modifiers += "c-";
        }
        if (event.altKey) {
          modifiers += "a-";
        }
        if (modifiers.length > 0 || keyChar.length > 1) {
          keyChar = "<" + modifiers + keyChar + ">";
        }
      }
    }
    if (isInsert && isEscape) {
      if (isEditable(event.srcElement) || !isEmbed(event.srcElement)) {
        event.srcElement.blur();
      }
      exitInsertMode();
      action = 2;
    }
    else if (findMode) {
      if (isEscape) {
        handleEscapeForFindMode();
        action = 2;
      } else if (event.keyCode === keyCodes.backspace || event.keyCode === keyCodes.deleteKey) {
        handleDeleteForFindMode();
        action = 2;
      } else if (event.keyCode === keyCodes.enter) {
        handleEnterForFindMode();
        action = 2;
      } else if (!keyChar) {
        action = 1;
      }
    }
    else if (isShowingHelpDialog && isEscape) {
      hideHelpDialog();
      action = 2;
    }
    else if (!isInsert || (event.keyCode >= keyCodes.f1 && event.keyCode <= keyCodes.f12)) {
      if (isEscape) {
        if (keyQueue) {
          action = 2;
        }
        mainPort.postMessage({
          handlerKey: "<esc>"
        });
      }
      else if (keyChar.length > 0) {
        if (isValidKey(keyChar)) {
          action = 2;
        }
        mainPort.postMessage({
          handlerKey: keyChar
        });
      }
      else {
        if (modifiers == null) {
          keyChar = KeyboardUtils.getKeyChar(event);
        }
        if (keyChar.length > 0 && !isPassKey(keyChar) && isValidKey(keyChar)) {
          action = 1;
        }
      }
    }
    if (action <= 0) {
      return;
    }
    if (action === 2) {
      DomUtils.suppressEvent(event);
    } else {
      DomUtils.suppressPropagation(event);
    }
    KeydownEvents.push(event);
  };

  isValidKey = function(key) {
    return currentCompletionKeys.indexOf(key) !== -1 || validFirstKeys[key] || isValidKey.numRegex.test(key);
  };
  isValidKey.numRegex = /^[1-9]/;

  isFocusable = function(element) {
    return isEditable(element) || isEmbed(element);
  };

  isEmbed = function(element) {
    var s = element.nodeName.toLowerCase();
    return s === "embed" || s === "object";
  };

  isEditable = function(target) {
    var focusableElements, noFocus, nodeName;
    if (target.isContentEditable) {
      return true;
    }
    nodeName = target.nodeName.toLowerCase();
    noFocus = ["radio", "checkbox"];
    if (nodeName === "input" && noFocus.indexOf(target.type) === -1) {
      return true;
    }
    focusableElements = ["textarea", "select"];
    return focusableElements.indexOf(nodeName) >= 0;
  };

  window.enterInsertMode = function(target) {
    enterInsertModeWithoutShowingIndicator(target);
    HUD.show("Insert mode");
  };

  enterInsertModeWithoutShowingIndicator = function(target) {
    insertModeLock = target;
  };

  exitInsertMode = function(target) {
    if (target === undefined || insertModeLock === target) {
      insertModeLock = null;
      HUD.hide();
    }
  };

  isInsertMode = function() {
    if (insertModeLock !== null) {
      return true;
    }
    if (document.activeElement && document.activeElement.isContentEditable) {
      enterInsertModeWithoutShowingIndicator(document.activeElement);
      return true;
    }
    return false;
  };

  getVisibleInputs = function(pathSet) {
    for (var element, rect, results = [], i = 0, _ref = pathSet.snapshotLength; i < _ref; ++i) {
      element = pathSet.snapshotItem(i);
      rect = DomUtils.getVisibleClientRect(element);
      if (rect) {
        results.push({
          element: element,
          rect: rect
        });
      }
    }
    return results;
  };
  
  updateFindModeQuery = function() {
    var error, escapeRegEx, hasNoIgnoreCaseFlag, parsedNonRegexQuery, pattern, text, _ref;
    findModeQuery.isRegex = settings.values.regexFindMode ? true : false;
    hasNoIgnoreCaseFlag = false;
    findModeQuery.parsedQuery = findModeQuery.rawQuery.replace(/\\./g, function(match) {
      switch (match) {
        case "\\r":
          findModeQuery.isRegex = true;
          return "";
        case "\\R":
          findModeQuery.isRegex = false;
          return "";
        case "\\I":
          hasNoIgnoreCaseFlag = true;
          return "";
        case "\\\\":
          return "\\";
        default:
          return match;
      }
    });
    findModeQuery.ignoreCase = !hasNoIgnoreCaseFlag && !Utils.hasUpperCase(findModeQuery.parsedQuery);
    if (findModeQuery.isRegex) {
      try {
        pattern = new RegExp(findModeQuery.parsedQuery, "g" + (findModeQuery.ignoreCase ? "i" : ""));
      } catch (_error) {
        error = _error;
        return;
      }
      text = document.body.innerText;
      findModeQuery.regexMatches = text.match(pattern);
      findModeQuery.activeRegexIndex = 0;
      findModeQuery.matchCount = (findModeQuery.regexMatches || []).length;
    } else {
      escapeRegEx = /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g;
      parsedNonRegexQuery = findModeQuery.parsedQuery.replace(escapeRegEx, function(ch) {
        return "\\" + ch;
      });
      pattern = new RegExp(parsedNonRegexQuery, "g" + (findModeQuery.ignoreCase ? "i" : ""));
      text = document.body.innerText;
      findModeQuery.matchCount = (text.match(pattern) || []).length;
    }
  };

  handleKeyCharForFindMode = function(keyChar) {
    findModeQuery.rawQuery += keyChar;
    updateFindModeQuery();
    performFindInPlace();
    showFindModeHUDForQuery();
  };

  handleEscapeForFindMode = function() {
    var range, selection;
    exitFindMode();
    restoreDefaultSelectionHighlight();
    selection = window.getSelection();
    if (!selection.isCollapsed) {
      range = window.getSelection().getRangeAt(0);
      window.getSelection().removeAllRanges();
      window.getSelection().addRange(range);
    }
    if (focusFoundLink()) { return; }
    if (findModeQueryHasResults && document.activeElement && DomUtils.isSelectable(document.activeElement) //
      && isDOMDescendant(findModeAnchorNode, document.activeElement)) {
      DomUtils.simulateSelect(document.activeElement);
      enterInsertModeWithoutShowingIndicator(document.activeElement);
    }
  };

  handleDeleteForFindMode = function() {
    if (! findModeQuery.rawQuery) {
      exitFindMode();
      performFindInPlace();
    } else {
      findModeQuery.rawQuery = findModeQuery.rawQuery.substring(0, findModeQuery.rawQuery.length - 1);
      updateFindModeQuery();
      performFindInPlace();
      showFindModeHUDForQuery();
    }
  };

  handleEnterForFindMode = function() {
    exitFindMode();
    focusFoundLink();
    document.body.classList.add("vimFindMode");
    settings.set("findModeRawQuery", findModeQuery.rawQuery);
  };

  performFindInPlace = function() {
    var cachedScrollX = window.scrollX, cachedScrollY = window.scrollY
      , query = findModeQuery.isRegex ? getNextQueryFromRegexMatches(0) : findModeQuery.parsedQuery;
    executeFind(query, {
      backwards: true,
      caseSensitive: !findModeQuery.ignoreCase
    });
    window.scrollTo(cachedScrollX, cachedScrollY);
    executeFind(query, {
      caseSensitive: !findModeQuery.ignoreCase
    });
  };

  executeFind = function(query, options) {
    var oldFindMode = findMode, result;
    findMode = true;
    document.body.classList.add("vimFindMode");
    HUD.hide(true);
    findModeQueryHasResults = !!window.find(query, options.caseSensitive, options.backwards, true, false, true, false);
    if (findChangeListened === 0) {
      findChangeListened = setTimeout(function() {
        document.addEventListener("selectionchange", restoreDefaultSelectionHighlight, true);
      }, 1000);
    }
    findMode = oldFindMode;
    findModeAnchorNode = document.getSelection().anchorNode;
  };

  restoreDefaultSelectionHighlight = function() {
    document.body.classList.remove("vimFindMode");
    document.removeEventListener("selectionchange", restoreDefaultSelectionHighlight, true);
    if (findChangeListened) {
      clearTimeout(findChangeListened);
      findChangeListened = 0;
    }
  };

  focusFoundLink = function() {
    if (findModeQueryHasResults) {
      var link, node = window.getSelection().anchorNode;
      while (node && node !== document.body) {
        if (node.nodeName.toLowerCase() === "a") {
          return node.focus ? node.focus() : false;
        }
        node = node.parentNode;
      }
    }
    return false;
  };

  isDOMDescendant = function(parent, node) {
    while (node !== null) {
      if (node === parent) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  };

  getNextQueryFromRegexMatches = function(stepSize) {
    var totalMatches;
    if (!findModeQuery.regexMatches) {
      return "";
    }
    totalMatches = findModeQuery.regexMatches.length;
    findModeQuery.activeRegexIndex += stepSize + totalMatches;
    findModeQuery.activeRegexIndex %= totalMatches;
    return findModeQuery.regexMatches[findModeQuery.activeRegexIndex];
  };

  findAndFocus = function(backwards) {
    var elementCanTakeInput, mostRecentQuery, query;
    mostRecentQuery = settings.values.findModeRawQuery || "";
    if (mostRecentQuery !== findModeQuery.rawQuery) {
      findModeQuery.rawQuery = mostRecentQuery;
      updateFindModeQuery();
    }
    query = findModeQuery.isRegex ? getNextQueryFromRegexMatches(backwards ? -1 : 1) : findModeQuery.parsedQuery;
    executeFind(query, {
      backwards: backwards,
      caseSensitive: !findModeQuery.ignoreCase
    });
    if (!findModeQueryHasResults) {
      HUD.showForDuration("No matches for '" + findModeQuery.rawQuery + "'", 1000);
      return;
    }
    elementCanTakeInput = document.activeElement && DomUtils.isSelectable(document.activeElement) && isDOMDescendant(findModeAnchorNode, document.activeElement);
    if (elementCanTakeInput) {
      handlerStack.push({
        keydown: function(event) {
          handlerStack.remove();
          if (KeyboardUtils.isEscape(event)) {
            DomUtils.simulateSelect(document.activeElement);
            enterInsertModeWithoutShowingIndicator(document.activeElement);
            return false;
          }
          return true;
        }
      });
    }
    focusFoundLink();
  };

  window.performFind = function() {
    findAndFocus();
  };

  window.performBackwardsFind = function() {
    findAndFocus(true);
  };

  followLink = function(linkElement) {
    if (linkElement.nodeName.toLowerCase() === "link") {
      window.location.href = linkElement.href;
    } else {
      linkElement.scrollIntoView();
      linkElement.focus();
      DomUtils.simulateClick(linkElement);
    }
  };
  
  goBy = function(relName, pattern) {
    if (relName && typeof relName === "string" && goBy.findAndFollowRel(relName)) {
      return true;
    }
    pattern = typeof pattern === "string" && (pattern = pattern.trim())
      ? pattern.toLowerCase().split(/\s*,\s*/).filter(function(s) { return s.length;})
      : (pattern instanceof Array) ? pattern : [];
    if (pattern.length > 0) {
      goBy.findAndFollowLink(pattern);
    }
  };

  goBy.findAndFollowLink = function(linkStrings) {
    var boundingClientRect, candidateLinks, computedStyle, exactWordRegex, link, linkString, links, linksXPath, _i, _j, _len, _len1;
    linksXPath = DomUtils.makeXPath(["a", "*[@onclick or @role='link' or contains(@class, 'button')]"]);
    links = DomUtils.evaluateXPath(linksXPath, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE);
    candidateLinks = [];
    _len = links.snapshotLength;
    while (0 <= --_len) {
      link = links.snapshotItem(_len);
      boundingClientRect = link.getBoundingClientRect();
      if (boundingClientRect.width === 0 || boundingClientRect.height === 0) {
        continue;
      }
      computedStyle = window.getComputedStyle(link, null);
      if (computedStyle.getPropertyValue("visibility") !== "visible" || computedStyle.getPropertyValue("display") === "none") {
        continue;
      }
      linkString = link.innerText.toLowerCase();
      for (_j = 0, _len1 = linkStrings.length; _j < _len1; _j++) {
        if (linkString.indexOf(linkStrings[_j]) !== -1) {
          candidateLinks.push(link);
          break;
        }
      }
    }
    _len = candidateLinks.length;
    if (_len === 0) {
      return;
    }
    while (0 <= --_len) {
      link = candidateLinks[_len];
      link.wordCount = link.innerText.trim().split(/\s+/).length;
      link.originalIndex = _len;
    }
    candidateLinks = candidateLinks.sort(function(a, b) {
      return (a.wordCount - b.wordCount) || (a.originalIndex - b.originalIndex);
    });
    _len = candidateLinks[0].wordCount + 1;
    candidateLinks = candidateLinks.filter(function(a) {
      return a.wordCount <= _len;
    });
    for (_i = 0, _len = linkStrings.length; _i < _len; _i++) {
      linkString = linkStrings[_i];
      exactWordRegex = /\b/.test(linkString[0]) || /\b/.test(linkString[linkString.length - 1]) ? new RegExp("\\b" + linkString + "\\b", "i") : new RegExp(linkString, "i");
      for (_j = 0, _len1 = candidateLinks.length; _j < _len1; _j++) {
        link = candidateLinks[_j];
        if (exactWordRegex.test(link.innerText)) {
          followLink(link);
          return true;
        }
      }
    }
    return false;
  };

  goBy.findAndFollowRel = function(value) {
    var element, elements, relTags, tag, _i, _j, _len, _len1;
    relTags = ["link", "a", "area"];
    for (_i = 0, _len = relTags.length; _i < _len; _i++) {
      tag = relTags[_i];
      elements = document.getElementsByTagName(tag);
      for (_j = 0, _len1 = elements.length; _j < _len1; _j++) {
        element = elements[_j];
        if (element.hasAttribute("rel") && element.rel.toLowerCase() === value) {
          followLink(element);
          return true;
        }
      }
    }
    return false;
  };

  window.goPrevious = function() {
    goBy("prev", settings.values.previousPatterns || "");
  };

  window.goNext = function() {
    goBy("next", settings.values.nextPatterns || "");
  };

  showFindModeHUDForQuery = function() {
    if (findModeQueryHasResults || !findModeQuery.parsedQuery) {
      HUD.show("/" + findModeQuery.rawQuery + " (" + findModeQuery.matchCount + " Matches)");
    } else {
      HUD.show("/" + findModeQuery.rawQuery + " (No Matches)");
    }
  };

  window.enterFindMode = function() {
    findModeQuery.rawQuery = "";
    findMode = true;
    HUD.show("/");
  };

  exitFindMode = function() {
    findMode = false;
    HUD.hide();
  };

  window.showHelpDialog = function(html) {
    var VimiumHelpDialog, container;
    if (isShowingHelpDialog || !(document.documentElement || document.body)) {
      return;
    }
    isShowingHelpDialog = true;
    container = document.createElement("div");
    container.id = "vimHelpDialogContainer";
    container.className = "vimB vimR";
    (document.documentElement || document.body).appendChild(container);
    container.innerHTML = html;
    VimiumHelpDialog = {
      getShowAdvancedCommands: function() {
        return settings.values.helpDialog_showAdvancedCommands ? true : false;
      },
      init: function() {
        this.dialogElement = document.getElementById("vimHelpDialog");
        document.getElementById("vimToggleAdvancedCommands").addEventListener("click", VimiumHelpDialog.toggleAdvancedCommands, false);
        this.dialogElement.style.maxHeight = window.innerHeight - 80;
        this.showAdvancedCommands(this.getShowAdvancedCommands());
      },
      toggleAdvancedCommands: function(event) {
        var showAdvanced = VimiumHelpDialog.getShowAdvancedCommands();
        DomUtils.suppressEvent(event);
        VimiumHelpDialog.showAdvancedCommands(!showAdvanced);
        settings.set("helpDialog_showAdvancedCommands", !showAdvanced);
      },
      showAdvancedCommands: function(visible) {
        var advancedEls, el, _i, _len;
        document.getElementById("vimToggleAdvancedCommands").innerHTML = visible ? "Hide advanced commands" : "Show advanced commands";
        advancedEls = VimiumHelpDialog.dialogElement.getElementsByClassName("vimHelpAdvanced");
        visible = visible ? "table-row" : "none";
        for (_i = 0, _len = advancedEls.length; _i < _len; _i++) {
          el = advancedEls[_i];
          el.style.display = visible;
        }
      }
    };
    VimiumHelpDialog.init();
    container.addEventListener("mousewheel", DomUtils.suppressPropagation, false);
    document.getElementById("vimCloseButton").addEventListener("click", hideHelpDialog, false);
    document.getElementById("vimOptionsPage").addEventListener("click", function(event) {
      DomUtils.suppressEvent(event);
      mainPort.postMessage({
        handler: "openOptionsPageInNewTab"
      });
    }, false);
  };

  hideHelpDialog = function(event) {
    var helpDialog = document.getElementById("vimHelpDialogContainer");
    if (helpDialog) {
      DomUtils.removeNode(helpDialog);
    }
    isShowingHelpDialog = false;
    if (event) {
      DomUtils.suppressEvent(event);
    }
  };

  HUD = {
    _tweenId: -1,
    _displayElement: null,
    _upgradeNotificationElement: null,
    showForDuration: function(text, duration) {
      HUD.show(text);
      HUD._showForDurationTimerId = setTimeout(HUD.hide, duration);
    },
    show: function(text) {
      if (!HUD.enabled()) {
        return;
      }
      clearTimeout(HUD._showForDurationTimerId);
      var el = HUD.displayElement();
      el.innerText = text;
      clearInterval(HUD._tweenId);
      HUD._tweenId = Tween.fade(el, 1.0, 150);
      el.style.display = "";
    },
    showUpgradeNotification: function(version) {
      var el = HUD.upgradeNotificationElement(), links;
      el.innerHTML = "Vimium has been updated to " + version + " (<a class='vimB vimI vimL' target='_blank' \
href='https://github.com/philc/vimium#release-notes'>what's new</a>).<a class='vimB vimI vimL vimHUDClose'>&#215;</a>";
      links = el.getElementsByTagName("a");
      links[0].addEventListener("click", HUD.onUpdateLinkClicked, false);
      links[1].addEventListener("click", function(event) {
        event.preventDefault();
        HUD.onUpdateLinkClicked(event);
      }, false);
      Tween.fade(el, 1.0, 150);
    },
    onUpdateLinkClicked: function(event) {
      DomUtils.suppressEvent(event);
      HUD.hideUpgradeNotification();
      mainPort.postMessage({
        handler: "upgradeNotificationClosed"
      });
    },
    hideUpgradeNotification: function() {
      var el = HUD.upgradeNotificationElement();
      Tween.fade(el, 0, 150, function() {
        el.style.display = "none";
      });
    },
    displayElement: function() {
      if (!HUD._displayElement) {
        HUD._displayElement = HUD.createHudElement();
        HUD._displayElement.style.right = "150px";
      }
      return HUD._displayElement;
    },
    upgradeNotificationElement: function() {
      if (!HUD._upgradeNotificationElement) {
        HUD._upgradeNotificationElement = HUD.createHudElement();
        HUD._upgradeNotificationElement.style.right = "315px";
      }
      return HUD._upgradeNotificationElement;
    },
    createHudElement: function() {
      var element = document.createElement("div");
      element.className = "vimB vimR vimHUD";
      document.documentElement.appendChild(element);
      return element;
    },
    hide: function(immediate) {
      clearInterval(HUD._tweenId);
      var el;
      if (!(el = HUD._displayElement)) {
      } else if (immediate) {
        el.style.display = "none";
      } else {
        HUD._tweenId = Tween.fade(el, 0, 150, function() {
          el.style.display = "none";
        });
      }
    },
    isReady: function() {
      return document.body != null;
    },
    enabled: function() {
      return !settings.values.hideHud;
    },
    destroy: function() {
      this._tweenId && clearInterval(this._tweenId);
      this._displayElement && DomUtils.removeNode(this._displayElement);
      HUD = null;
    }
  };

  Tween = {
    fade: function(element, toAlpha, duration, onComplete) {
      var state = {
        duration: duration,
        startTime: Date.now(),
        from: parseInt(element.style.opacity) || 0,
        to: toAlpha,
        onUpdate: null,
        timerId: 0
      };
      state.onUpdate = function(value) {
        element.style.opacity = value;
        if (value === state.to && onComplete) {
          onComplete();
        }
      };
      return state.timerId = setInterval((function() {
        Tween.performTweenStep(state);
      }), 50);
    },
    performTweenStep: function(state) {
      var elapsed = Date.now() - state.startTime;
      if (elapsed >= state.duration) {
        clearInterval(state.timerId);
        state.onUpdate(state.to);
      } else {
        state.onUpdate((elapsed / state.duration) * (state.to - state.from) + state.from);
      }
    }
  };

  CursorHider = {
    cursorHideStyle: null,
    isScrolling: false,
    onScroll: function(event) {
      CursorHider.isScrolling = true;
      if (!CursorHider.cursorHideStyle.parentElement) {
        document.head.appendChild(CursorHider.cursorHideStyle);
      }
    },
    onMouseMove: function(event) {
      if (CursorHider.cursorHideStyle.parentElement && !CursorHider.isScrolling) {
        CursorHider.cursorHideStyle.remove();
      }
      return CursorHider.isScrolling = false;
    },
    init: function() {
      return;
      this.cursorHideStyle = document.createElement("style");
      this.cursorHideStyle.innerHTML = "body * {pointer-events: none !important; cursor: none !important;}\nbody, html {cursor: none !important;}";
      window.addEventListener("mousemove", this.onMouseMove);
      window.addEventListener("scroll", this.onScroll);
    }
  };

  window.settings = settings;

  window.HUD = HUD;

  window.KeydownEvents = KeydownEvents;

  window.frameId = frameId;

  window.mainPort = mainPort;

  requestHandlers = {
    settings: settings.ReceiveMessage,
    registerFrame: function(request) {
      if (request.tabId) {
        ELs.focusMsg.tabId = request.tabId;
      }
      if (request.css) {
        DomUtils.DocumentReady(requestHandlers.injectCSS.bind(null, request), true);
      }
      if (request.version) {
        HUD.showUpgradeNotification(request.version);
      }
    },
    reRegisterFrame: function(request) {
      mainPort.postMessage({
        handlerSettings: request ? "rereg" : "reg",
        isTop: window.top === window.self,
        frameId: ((document.body && document.body.nodeName.toLowerCase() === "frameset") ? -1 : frameId)
      });
    },
    injectCSS: function(request) {
      var css = document.getElementById("vimUserCss");
      if (css) {
        css.innerHTML = request.css;
      } else {
        css = document.createElement("style");
        css.id = "vimUserCss";
        css.type = "text/css";
        css.innerHTML = request.css;
        document.head.appendChild(css);
      }
    },
    hideUpgradeNotification: function() {
      HUD.hideUpgradeNotification();
    },
    showUpgradeNotification: function(request) {
      HUD.showUpgradeNotification(request.version);
    },
    showHUDforDuration: function(request) {
      HUD.showForDuration(request.text, request.duration);
    },
    focusFrame: function(request) {
      if (frameId !== request.frameId) { return; }
      if (window.innerWidth < 3 || window.innerHeight < 3) {
        mainPort.postMessage({
          handler: "nextFrame",
          frameId: frameId
        });
        return;
      }
      window.focus();
      if (document.body && request.highlight) {
        var borderWas = document.body.style.border;
        document.body.style.border = '5px solid yellow';
        setTimeout((function() {
          document.body.style.border = borderWas;
        }), 200);
      }
    },
    refreshCompletionKeys: function(response) {
      currentCompletionKeys = response.completionKeys;
      keyQueue = response.keyQueue;
      var vfk;
      if (vfk = response.validFirstKeys) {
        validFirstKeys = vfk;
      }
    },
    setScrollPosition: function(request) {
      var scrollX = request.scroll[0], scrollY = request.scroll[1];
      if (scrollX > 0 || scrollY > 0) {
        DomUtils.DocumentReady(window.scrollTo.bind(window, scrollX, scrollY));
      }
    },
    executePageCommand: function(request) {
      if (request.count < 0) {
        Utils.invokeCommandString(request.command, -request.count);
      } else {
        for (var i = 0, _ref = request.count; i < _ref; ++i) {
          Utils.invokeCommandString(request.command);
        }
      }
      currentCompletionKeys = request.completionKeys;
      keyQueue = "";
    },
    getActiveState: function() {
      return {
        enabled: isEnabledForUrl,
        passKeys: passKeys
      };
    },
    setState: function(request) {
      if (isEnabledForUrl = request.enabled) {
        initializeWhenEnabled(request.passKeys);
      } else {
        HUD.hide();
      }
    }
  };

  chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
    if (!(isEnabledForUrl || request.name === 'getActiveState' || request.name === 'setState')) {
      return;
    }
    var handler = requestHandlers[request.name];
    if (handler) {
      handler = handler(request);
      if (handler != null) {
        sendResponse(handler);
      }
    }
  });
  
  ELs.destroy = function() {
    isEnabledForUrl = false;
    window.isEnabledForUrl_g = false;
    window.removeEventListener("unload", this.onUnload);
    window.removeEventListener("focus", this.onFocus);
    window.removeEventListener("keydown", this.onKeydown, true);
    window.removeEventListener("keypress", this.onKeypress, true);
    window.removeEventListener("keyup", this.onKeyup, true);
    document.removeEventListener("focus", this.docOnFocus, true);
    document.removeEventListener("blur", this.onBlur, true);
    document.removeEventListener("DOMActivate", this.onActivate, true);
    Vomnibar.destroy();
    LinkHints.destroy();
    HUD.destroy();
    ELs = null;
    mainPort = null;
    requestHandlers = null;
    console.log("%cvim %c#" + frameId, "color:red", "color:blue", "has destroyed.");
  };

  settings.addEventListener("load", function(response) {
    LinkHints.init();
    Scroller.init();
    CursorHider.init();
    if (!response || !response.enabled) {
      isEnabledForUrl = false;
      HUD.hide();
      return;
    }
    isEnabledForUrl = true;
    initializeWhenEnabled(response.passKeys);
    requestHandlers.refreshCompletionKeys(response);
  });

  ((settings.load(null, false, {
      handler: "isEnabledForUrl",
      url: window.location.href
    }) < 0)
    ? settings.addEventListener.bind(settings, "load")
    : DomUtils.DocumentReady
  )(function() {
    requestHandlers.reRegisterFrame();
    window.addEventListener("unload", ELs.onUnload = mainPort.postMessage.bind(mainPort, {
        handlerSettings: "unreg",
        frameId: frameId,
        isTop: window.top === window.self,
    }, null));
    window.addEventListener("focus", ELs.onFocus = mainPort.postMessage.bind(mainPort,
    ELs.focusMsg = {
      handler: "frameFocused",
      tabId: 0,
      frameId: frameId
    }, null));
  });

})();
