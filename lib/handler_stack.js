"use strict";
// Generated by CoffeeScript 1.8.0
(typeof global !== "undefined" ? (window || global) : window).HandlerStack = function HandlerStack(events) {
  var stacks, events2, _i;
  this._counter = 1;
  this.current = 0;
  this.stacks = stacks = {};
  this.table = [];
  
  this.debug = false;
  this.eventNumber = 0;
  this.stopBubblingAndTrue = {};
  this.stopBubblingAndFalse = {};
  this.restartBubbling = {};
  
  events = events || this.defaultEvents;
  _i = events.length;
  this.events = events2 = new Array(_i);
  while (0 <= --_i) {
    stacks[events2[_i] = events[_i]] = []; // create a copy of event array
  };
};

(typeof global !== "undefined" ? (window || global) : window).HandlerStack.prototype = {  
  defaultEvents: ["keydown", "keypress", "keyup", "DOMActivate", //
    "click", "updateBadge", "registerKeyQueue", "registerStateChange", "focus", "blur"
  ],
  reset: function() {
    if (this.current) {
      console.log("vim: error %creset handlers:", "color:red;", "now in", this.current);
      return;
    }
    this.stacks = {};
    this.table = [];
    this.eventNumber = 0;
  },
  push: function(handler) {
    var stacks = this.stacks, events = this.events, _i = events.length, line, key, func, id;
    line = new Array(_i + 2);
    id = ++this._counter;
    line[_i] = id;
    line[_i + 1] = handler._name || ("anon-" + id);
    while (0 <= --_i) {
      key = events[_i];
      func = handler[key];
      if (!func) {
        line[_i] = null;
        continue;
      }
      stacks[key].push(func, id);
      line[_i] = func;
    }
    this.table.push(line);
    return line[events.length];
  },
  unshift: function(handler) {
    var stacks = this.stacks, events = this.events, _i = events.length, line, key, func;
    line = new Array(_i + 2);
    line[_i] = ++this._counter;
    line[_i + 1] = (handler._name || ("anon-" + this._counter)) + "/unshift";
    while (0 <= --_i) {
      key = events[_i];
      func = handler[key];
      if (!func) {
        line[_i] = null;
        continue;
      }
      stacks[key].unshift(func, id);
      line[_i] = func;
    }
    this.table.unshift(line);
    return line[events.length];
  },
  bubbleEvent: function(type, event) {
    var handler, _ref = this.stacks[type], _i = _ref ? _ref.length : 0, result;
    ++this.eventNumber;
    while (0 <= (_i -= 2)) {
      handler = _ref[_i];
      this.current = _ref[_i + 1];
      result = handler.call(this, event);
      if (this.debug) {
        this.logResult(type, event, this.current, result);
      }
      if (! result) {
        if (this.isChromeEvent(event)) {
          DomUtils.suppressEvent(event);
        }
        result = false;
      } else if (result === this.stopBubblingAndTrue) {
        result = true;
      } else if (result === this.stopBubblingAndFalse) {
        result = false;
      } else if (result === this.restartBubbling) {
        result = this.bubbleEvent(type, event);
      } else {
        continue;
      }
      this.current = 0;
      return result;
    }
    this.current = 0;
    return true;
  },
  remove: function(id) {
    var line, func, stack, table = this.table, events = this.events, _i = table.length, _last = events.length;
    if (this.current) {
      if (id == null) {
        id = this.current;
      } else if (id !== this.current) {
        console.log("vim: error %cremove handlers:", "color:red;", id, "/", this.current);
        return -1;
      }
    }
    if (!(id > 0)) {
      return 0;
    }
    while (0 <= --_i) {
      line = table[_i];
      if (line[_last] === id) {
        break;
      }
    }
    if (_i < 0) {
      return -1;
    }
    table.splice(_i, 1);
    while (0 <= --_last) {
      if (!(func = line[_last])) {
        continue;
      }
      stack = this.stacks[events[_last]];
      _i = stack.length + 1;
      while (0 < (_i -= 2)) {
        if (stack[_i] === id) {
          stack.splice(_i - 1, 2);
          break;
        }
      }
    }
    return id;
  },
  isChromeEvent: function(event) {
    return event && event.preventDefault && event.stopImmediatePropagation;
  },
  alwaysContinueBubbling: function(handler) {
    handler();
    return true;
  },
  neverContinueBubbling: function(handler) {
    handler();
    return false;
  },
  logResult: function(type, event, handler, result) {
    var label;
    if (type === "updateBadge" || type === "registerKeyQueue") {
      return;
    }
    switch (result) {
    case this.stopBubblingAndTrue:  label = "stop/true";  break;
    case this.stopBubblingAndFalse: label = "stop/false"; break;
    case this.restartBubbling:      label = "rebubble";   break;
    case true:                      label = "continue";   break;
    }
    label || (label = result ? "continue/truthy" : "suppress");
    console.log("" + this.eventNumber, type, handler._name, label);
  }
};

(typeof global !== "undefined" ? (window || global) : window).handlerStack = //
  new (typeof global !== "undefined" ? (window || global) : window).HandlerStack();