"use strict";
// Generated by CoffeeScript 1.8.0
var handlerStack = {
  _counter: 1,
  current: null,
  stacks: {},
  table: [],
  debug: false,
  eventNumber: 0,
  stopBubblingAndTrue: {},
  stopBubblingAndFalse: {},
  restartBubbling: {},
  events: ["keydown", "keypress", "keyup", //
    "DOMActivate", "click", "focus", "blur", //
    "updateBadge", "registerKeyQueue", "registerStateChange" //
  ],
  init: function() {
    var stacks, events, _i;
    for (stacks = this.stacks, events = this.events, _i = events.length; 0 <= --_i; ) {
      stacks[events[_i]] = [];
    };
  },
  reset: function() {
    if (this.current) {
      console.log("vim: error %creset handlers:", "color:red;", "now in", this.current[2]);
      return;
    }
    this.stacks = {};
    this.table = [];
    this.eventNumber = 0;
  },
  push: function(handler) {
    var stacks = this.stacks, events = this.events, _i = events.length, line, key, func, id;
    id = ++this._counter;
    line = new Array(_i + 3);
    line[0] = handler._this || null;
    line[1] = id;
    line[2] = handler._name || ("anon-" + id);
    while (0 <= --_i) {
      key = events[_i];
      func = handler[key];
      if (typeof func !== "function") {
        continue;
      }
      stacks[key].push(func, line);
      line[_i + 3] = func;
    }
    this.table.push(line);
    return id;
  },
  unshift: function(handler) {
    var stacks = this.stacks, events = this.events, _i = events.length, line, key, func, id;
    id = ++this._counter;
    line = new Array(_i + 2);
    line[0] = handler._this || null;
    line[1] = id;
    line[2] = (handler._name || ("anon-" + id)) + "/unshift";
    while (0 <= --_i) {
      key = events[_i];
      func = handler[key];
      if (!func) {
        continue;
      }
      stacks[key].unshift(func, line);
      line[_i + 3] = func;
    }
    this.table.unshift(line);
    return id;
  },
  bubbleEvent: function(type, event) {
    var handler, _ref = this.stacks[type], _i = _ref ? _ref.length : 0, result;
    ++this.eventNumber;
    while (0 <= (_i -= 2)) {
      handler = _ref[_i];
      this.current = _ref[_i + 1];
      result = handler.call(this.current[0], event);
      if (this.debug) {
        this.logResult(type, event, this.current, result);
      }
      if (! result) {
        if (this.isChromeEvent(event)) {
          DomUtils.suppressEvent(event);
        }
        result = false;
      } else if (result === true) {
        continue;
      } else if (result === this.stopBubblingAndTrue) {
        result = true;
      } else if (result === this.stopBubblingAndFalse) {
        result = false;
      } else if (result === this.restartBubbling) {
        result = this.bubbleEvent(type, event);
      } else {
        continue;
      }
      break;
    }
    this.current = null;
    return true;
  },
  remove: function(id) {
    var line, stack, table, events, _i, _last;
    if (this.current) {
      if (id == null) {
        id = this.current[1];
      } else if (id !== this.current[1]) {
        console.log("vim: error %cremove handlers:", "color:red;", id, "/", this.current[2]);
        return -1;
      }
    } else if (!(id > 0)) {
      return 0;
    }
    for (table = this.table, _i = table.length; 0 <= --_i; ) {
      line = table[_i];
      if (line[1] === id) {
        break;
      }
    }
    if (_i < 0) {
      return -1;
    }
    table.splice(_i, 1);
    for (events = this.events, _last = events.length; 3 <= --_last; ) {
      if (line[_last] === undefined) {
        continue;
      }
      stack = this.stacks[events[_last - 3]];
      _i = stack.lastIndexOf(line);
      if (_i > 0) {
        stack.splice(_i - 1, 2);
      }
    }
    return id;
  },
  isChromeEvent: function(event) {
    return event && event.preventDefault && event.stopImmediatePropagation;
  },
  alwaysContinueBubbling: function(handler) {
    handler();
    return true;
  },
  neverContinueBubbling: function(handler) {
    handler();
    return false;
  },
  logResult: function(type, event, handler, result) {
    var label;
    if (type === "updateBadge" || type === "registerKeyQueue") {
      return;
    }
    switch (result) {
    case this.stopBubblingAndTrue:  label = "stop/true";  break;
    case this.stopBubblingAndFalse: label = "stop/false"; break;
    case this.restartBubbling:      label = "rebubble";   break;
    case true:                      label = "continue";   break;
    }
    label || (label = result ? "continue/truthy" : "suppress");
    console.log("" + this.eventNumber, type, handler._name, label);
  }
};

handlerStack.init();